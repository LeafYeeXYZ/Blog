---
title: Goå­¦ä¹ ç¬”è®°
comment: true
excerpt: false
date: 2024-05-02 12:00:00
categories: ç¬”è®°
tags: [Note,Go,Coding]
cover: images/cover/go.jpeg
---
**å°é¢ä½œè€…:[NOEYEBROW](https://x.com/noeyebrow313)**

**è¯·å…ˆé˜…è¯»[JavaScriptå­¦ä¹ ç¬”è®°](/2024/01/17/JavaScript/)å’Œ[TypeScriptå­¦ä¹ ç¬”è®°](/2024/03/06/TypeScript/)**

**æ¨èé˜…è¯»:[Golangä¸­æ–‡å­¦ä¹ æ–‡æ¡£](https://golang.halfiisland.com/essential/)**

# ç®€ä»‹
`Go` æ˜¯ä¸€ç§å¹¶å‘æ”¯æŒã€åƒåœ¾å›æ”¶çš„ç¼–è¯‘å‹ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œæ—¨åœ¨åˆ›é€ ä¸€ç§å…·æœ‰é™æ€ç¼–è¯‘è¯­è¨€çš„é«˜æ€§èƒ½å’ŒåŠ¨æ€è¯­è¨€çš„é«˜æ•ˆå¼€å‘ä¹‹é—´çš„ç†æƒ³å¹³è¡¡

åœ¨[å®˜ç½‘](https://go.dev/)ä¸‹è½½å®‰è£…åŒ…ï¼Œå®‰è£…å®Œæˆåï¼Œå¯ä»¥åœ¨ç»ˆç«¯è¾“å…¥ `go version` æŸ¥çœ‹ç‰ˆæœ¬å·å¹¶ç¡®è®¤å®‰è£…æˆåŠŸ

- `Go` çš„æ³¨é‡Šä¸ `JavaScript` ç›¸åŒ; å˜é‡åªèƒ½ç”±å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿ç»„æˆï¼Œä¸”ä¸èƒ½ä»¥æ•°å­—å¼€å¤´; å˜é‡å’Œå‡½æ•°é‡‡ç”¨é©¼å³°å‘½åæ³•
- `Go` çš„è¿ç®—ç¬¦å’Œ `JavaScript` ä¹Ÿç±»ä¼¼, ä½†æ˜¯ `++` å’Œ `--` å¿…é¡»åç½®; æ•°å­—ä¹Ÿå’Œ `JavaScript` ä¸€æ ·ï¼Œå¯ä»¥æœ‰ `_` åˆ†éš”ç¬¦å’Œä¸åŒè¿›åˆ¶
- `Go` çš„å­—ç¬¦å­—é¢é‡ä½¿ç”¨ `''`, æ”¯æŒ `Unicode`; å­—ç¬¦ä¸²å­—é¢é‡ä½¿ç”¨ `""` æˆ– <code>``</code>
- ~~ä½ è¯´å¾—å¯¹, ä½†æ˜¯ `if err != nil`~~

```bash
# è¿è¡Œ
go run main.go
# ç¼–è¯‘
go build main.go
```

#### go mod
`Go` 1.11 ç‰ˆæœ¬ä¹‹åå¼•å…¥äº† `go mod` åŒ…ç®¡ç†å·¥å…·, å¯ä»¥åœ¨é¡¹ç›®ä¸­ä½¿ç”¨, ç”¨äºç®¡ç†é¡¹ç›®çš„ä¾èµ–; å¯ä»¥åœ¨[https://pkg.go.dev/](https://pkg.go.dev/)ä¸ŠæŸ¥æ‰¾ä¾èµ–

`go.mod` ç›¸å½“äº `package.json`; `go.sum` ç›¸å½“äº `package-lock.json`

```bash
# åœ¨ GitHub ä¸Šåˆ›å»ºä¸€ä¸ªæ–°çš„ä»“åº“
git clone xxx
# åˆå§‹åŒ–æ¨¡å—
go mod init github.com/xxx/xxx

# å®‰è£…ä¾èµ–
go mod download
# æ·»åŠ ä¾èµ–
go get github.com/xxx/xxx
# ç§»é™¤ä¾èµ–
go get github.com/xxx/xxx@none

# å®‰è£…éœ€è¦çš„ä¾èµ–, ç§»é™¤ä¸éœ€è¦çš„ä¾èµ–
go mod tidy

# å®‰è£…å‘½ä»¤è¡Œç¨‹åº, ç›¸å½“äº npm install -g
go install github.com/xxx/xxx
# è¿è¡Œå‘½ä»¤è¡Œç¨‹åº, ç›¸å½“äº npx xxx
go run github.com/xxx/xxx
```

> `go mod` å®é™…ä¸Šæ˜¯åŸºäº `git` ç­‰ç‰ˆæœ¬æ§åˆ¶å·¥å…·çš„

# å¯¼å…¥å¯¼å‡º
`Go` ä¸­çš„åŒ…å¯èƒ½åŒ…å«å¤šä¸ªæ–‡ä»¶ï¼Œä½†æ˜¯åªèƒ½æœ‰ä¸€ä¸ª `main` åŒ…ï¼Œ`main` åŒ…æ˜¯ç¨‹åºçš„å…¥å£

```go
package main // åŒ…å£°æ˜

import "fmt" // å¼•å…¥åŒ…
import o "os" // å¼•å…¥åŒ…å¹¶é‡å‘½å
import (
    "fmt" // æ‰¹é‡å¼•å…¥åŒ…
    _ "os" // åŒ¿åå¼•å…¥, é€šå¸¸æ˜¯ç”¨äºè°ƒç”¨åŒ…ä¸­çš„ init å‡½æ•°
)

func main() { // å…¥å£å‡½æ•°
    fmt.Println("Hello, World!")
}

// Go ç¦æ­¢å¾ªç¯å¯¼å…¥åŒ…
```

```go
package demo

import "fmt"

func privateFunc() {
    fmt.Println("privateFunc")
} // å°å†™å­—æ¯å¼€å¤´çš„å‡½æ•°ä¸ºç§æœ‰å‡½æ•°

func PublicFunc() {
    fmt.Println("PublicFunc")
} // å¤§å†™å­—æ¯å¼€å¤´çš„å‡½æ•°ä¸ºå…¬æœ‰å‡½æ•°

// è¯¥è§„åˆ™é€‚ç”¨äºå˜é‡ã€å¸¸é‡ã€ç»“æ„ä½“ã€æ¥å£ç­‰
```

# æ•°æ®ç±»å‹
| ç±»å‹ | æè¿° | ç¤ºä¾‹ |
| :---: | :---: | :---: |
| `bool` | å¸ƒå°”å‹ | `true`, `false` |
| `uint8/16/32/64` | æ— ç¬¦å·æ•´å‹ | `0`, `255` |
| `int8/16/32/64` | æœ‰ç¬¦å·æ•´å‹ | `-128`, `127` |
| `uint/int` | ç›¸å½“äº `Rust` ä¸­çš„ `usize` | `0`, `255` |
| `uintptr` | æ— ç¬¦å·æ•´å‹ï¼Œç”¨äºå­˜æ”¾ä¸€ä¸ªæŒ‡é’ˆ | `0x123456` |
| `float32/64` | æµ®ç‚¹å‹ | `3.14`, `0.618` |
| `complex64/128` | å¤æ•° | `3.14+0i`, `0.618+0i` |
| `byte` | `uint8` çš„åˆ«å, è¡¨ç¤º `ASCII` ç  | `byte('A')` |
| `rune` | `int32` çš„åˆ«å, è¡¨ç¤º `Unicode` ç  | `rune('ä¸­')` |
| `string` | å­—ç¬¦ä¸², å¯ä»¥è½¬ä¸º `[]byte` | `"Hello, World!"` |
| `[]T` | åˆ‡ç‰‡, åŠ¨æ€æ•°ç»„ | `[]int{1, 2, 3}` |
| `[n]T` | æ•°ç»„, å›ºå®šé•¿åº¦æ•°ç»„ | `[3]int{1, 2, 3}`, `n` å¿…é¡»æ˜¯å¸¸é‡ |
| `map[K]V` | æ˜ å°„, é”®å€¼å¯¹ | `map[string]int{"a": 1, "b": 2}` |
| `struct` | ç»“æ„ä½“, è‡ªå®šä¹‰ç±»å‹ | `type Person struct { Name string; Age int }` |
| `interface` | æ¥å£, æŠ½è±¡ç±»å‹ | `type Animal interface { Eat() }` |
| `func` | å‡½æ•°, å‡½æ•°ç±»å‹ | `func Add(a, b int) int { return a + b }` |
| `chan` | é€šé“, ç”¨äºåç¨‹é—´é€šä¿¡ (åé¢ç»†è®²) | `ch := make(chan int)` |
| `*T` | æŒ‡é’ˆ, æŒ‡å‘ `T` ç±»å‹çš„æŒ‡é’ˆ (åé¢ç»†è®²) | `var p *int = &a` |

- **ç±»å‹è½¬æ¢**: `int(3.14)`ã€`(func() int)(xxx)` ç­‰, ä¸å­˜åœ¨éšå¼ç±»å‹è½¬æ¢
- **ç±»å‹æ–­è¨€**: `value.(int)`, è¯¥è¯­å¥è¿”å› `è½¬æ¢åçš„å€¼, è½¬æ¢æ˜¯å¦æˆåŠŸ` ä¸¤ä¸ªè¿”å›å€¼; å¸¸ç”¨äºåˆ¤æ–­æ¥å£å˜é‡çš„å®é™…ç±»å‹
- **ç±»å‹åˆ¤æ–­**: `value.(type)`, è¯¥è¯­å¥åªèƒ½ç”¨äº `switch` è¯­å¥ä¸­, ç”¨äºåˆ¤æ–­æ¥å£å˜é‡çš„å®é™…ç±»å‹

```go
var a float64 = 3.14
var b int = int(a)
switch a.(type) {
    case int:
        fmt.Println("int")
    case float64:
        fmt.Println("float64")
} // float64
```

#### é»˜è®¤å€¼
ä¸åŒäº `JavaScript`, `Go` å˜é‡å³ä½¿æ²¡æœ‰èµ‹å€¼ä¹Ÿä¼šæœ‰é»˜è®¤å€¼

| ç±»å‹ | é»˜è®¤å€¼ (é›¶å€¼) |
| :---: | :---: |
| `bool` | `false` |
| æ•°å­— | `0` |
| `string` | `""` |
| æ•°ç»„ | å¯¹åº”ç±»å‹çš„é›¶å€¼, å¦‚ `[3]int` ä¸º `[0, 0, 0]` |
| `struct` | å¯¹åº”ç±»å‹çš„é›¶å€¼, å¦‚ `Person` ä¸º `Person{}` |
| å…¶ä»– | `nil` |

> `nil` å’Œ `null` ä¸åŒ, å…¶æœ¬èº«ä¸å±äºä»»ä½•ç±»å‹

#### è‡ªå®šä¹‰ç±»å‹
```go
type MyInt int
var num MyInt = 123
```

> é€šå¸¸ç”¨äºç±»å‹åˆ«å (æœ‰çš„åº“çš„ç±»å‹åå¾ˆé•¿)ã€é™„åŠ æ–¹æ³•ã€å£°æ˜ç»“æ„ä½“å­—æ®µç­‰

# å¸¸é‡
å¸¸é‡çš„å€¼ä¸èƒ½åœ¨è¿è¡Œæ—¶ä¿®æ”¹ (å³è¢«å†™æ­»åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­), å…¶å€¼åªèƒ½è¯´åŸºæœ¬æ•°æ®ç±»å‹, å¯èƒ½æ¥æºäºå­—é¢é‡ã€å…¶ä»–å¸¸é‡æ ‡è¯†ç¬¦ã€å¸¸é‡è¡¨è¾¾å¼ç­‰; **å¸¸é‡çš„ç±»å‹å¯ä»¥çœç•¥**

```go
const constNum = 123
const constStr = "Hello, World!"
const constExp = 1 + 2 + constNum

// æ‰¹é‡å£°æ˜
const (
    constA = 1
    constB = 2
    constC = 3
)
```

#### iota
`iota` æ˜¯ `Go` è¯­è¨€çš„å¸¸é‡è®¡æ•°å™¨, åªèƒ½åœ¨å¸¸é‡çš„è¡¨è¾¾å¼ä¸­ä½¿ç”¨, ä¸”æ¯æ¬¡ä½¿ç”¨ `iota` æ—¶éƒ½ä¼šè‡ªå¢ `1`

```go
const (
    Num = iota // 0
    Num1 // 1
    Num2 // 2
)

const (
    Num = iota*2 // 0
    Num1 // 2
    Num2 // 4
    Num3 = iota // 3
    Num4 // 4
)
```

# å˜é‡
å˜é‡çš„å€¼å¯ä»¥åœ¨è¿è¡Œæ—¶ä¿®æ”¹, å…¶å€¼å¯ä»¥æ˜¯ä»»æ„ç±»å‹, ä½†æ˜¯ç±»å‹ä¸€æ—¦ç¡®å®šå°±ä¸èƒ½ä¿®æ”¹; `Go` çš„ç±»å‹æ¨æ–­å¿…é¡»é€šè¿‡ `:=` æ‰‹åŠ¨è¿›è¡Œ

```go
var varNum int = 123
var varStr string = "Hello, World!"
var (
    varA int = 1
    varB string = "Hello"
)
var numA, numB, numC int = 1, 2, 3

// ç±»å‹æ¨æ–­, æ­¤æ—¶åº”çœç•¥ var
varNum := 123
varStr := "Hello, World!"

// ç”±äº nil ä¸å±äºä»»ä½•ç±»å‹, æ‰€ä»¥ä¸èƒ½ä½¿ç”¨ç±»å‹æ¨æ–­
```

> `Go` ä¸­çš„å˜é‡å£°æ˜å¿…é¡»ä½¿ç”¨, å¦åˆ™ä¼šæŠ¥é”™; å¦‚æœç¡®å®ä¸éœ€è¦ä½¿ç”¨, å¯ä»¥ä½¿ç”¨ `_` å ä½ç¬¦

#### è§£æ„èµ‹å€¼
```go
var a, b := 1, 2
fmt.Println(a, b) // 1, 2
a, b = b, a
fmt.Println(a, b) // 2, 1
```

# ä½œç”¨åŸŸ
`Go` ä¸­å¯ä»¥æ‰‹åŠ¨ç”¨ `{}` åˆ›å»ºä½œç”¨åŸŸ, ä½œç”¨åŸŸå†…çš„å˜é‡åªèƒ½åœ¨ä½œç”¨åŸŸå†…ä½¿ç”¨

```go
package main

import "fmt"

var a = 1

func main() {
    fmt.Println(a) // 1
    {
        var a = 2
        fmt.Println(a) // 2
    }
    fmt.Println(a) // 1
}
```

# è¾“å…¥è¾“å‡º
| å‡½æ•° | æè¿° |
| :---: | :---: |
| `fmt.Print(xxx)` | æ‰“å°, ä¸æ¢è¡Œ |
| `fmt.Println(xxx)` | æ‰“å°, æ¢è¡Œ |
| `fmt.Printf(xxx, var)` | æ‰“å°, æ ¼å¼åŒ–è¾“å‡º |
| `fmt.Scan(&var)` | è¾“å…¥, æ ¹æ®ç©ºæ ¼æˆ–æ¢è¡Œç¬¦åˆ†å‰² |
| `fmt.Scanln(&var)` | è¾“å…¥, æ ¹æ®æ¢è¡Œç¬¦åˆ†å‰² |
| `fmt.Scanf(xxx, &var)` | è¾“å…¥, æ ¹æ®æ ¼å¼åŒ–è¾“å…¥ |

```go
package main

import "fmt"

func main() {
    var (
        num int
        str string
    )
    fmt.Print("è¯·è¾“å…¥ä¸€ä¸ªæ•´æ•°: ")
    fmt.Scan(&num)
    fmt.Print("è¯·è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²: ")
    fmt.Scanln(&str)
    fmt.Printf("num: %d, str: %s\n", num, str)
}
```

#### æ ¼å¼åŒ–
| æ ¼å¼åŒ– | æè¿° | æ¥å—ç±»å‹ |
| :---: | :---: | :---: |
| `%%` | ç™¾åˆ†å· | æ—  |
| `%s` | å­—ç¬¦ä¸² | `string` / `[]byte` |
| `%d` | åè¿›åˆ¶æ•´æ•° | å„ç§æ•´æ•°ç±»å‹ |
| `%f` | æµ®ç‚¹æ•° | `float32/64` |
| `%t` | å¸ƒå°”å€¼ | `bool` |
| `%v` | å€¼åŸæœ¬çš„å½¢å¼ï¼Œå¤šç”¨äºæ•°æ®ç»“æ„çš„è¾“å‡º | ä»»æ„ç±»å‹ |
| `%#v` | å€¼çš„ `Go` è¯­æ³•è¡¨ç¤º | ä»»æ„ç±»å‹ |
| `%+v` | ç±»ä¼¼ `%v`, ä½†è¾“å‡ºç»“æ„ä½“æ—¶ä¼šæ·»åŠ å­—æ®µå | ä»»æ„ç±»å‹ |
| `%T` | å€¼çš„ç±»å‹ | ä»»æ„ç±»å‹ |
| `%p` | æŒ‡é’ˆæŒ‡å‘çš„åœ°å€ | `*T` |

# æ¡ä»¶è¯­å¥
```go
// if else
if num > 0 {
    fmt.Println("num > 0")
} else if num < 0 {
    fmt.Println("num < 0")
} else {
    fmt.Println("num = 0")
}

// if åˆå§‹åŒ–è¯­å¥
if msg := "Hello"; num > 0 {
    fmt.Println(msg)
} // msg åªåœ¨ if ä½œç”¨åŸŸå†…æœ‰æ•ˆ

// switch
switch num {
    case 1:
        fmt.Println("num = 1")
    case 2:
        fmt.Println("num = 2")
    default:
        fmt.Println("num = 0")
}
str := "Hello"
switch { // ç›¸å½“äº switch true
    case str == "Hello":
        fmt.Println("str = Hello")
    case str == "World":
        fmt.Println("str = World")
    default:
        fmt.Println("str = None")
}

// goto, åˆ«ç”¨, å¯è¯»æ€§å·®
for i := 0; i < 10; i++ {
    if i == 5 {
        goto end
    }
    fmt.Println(i)
}
end: // æ ‡ç­¾è¯­å¥
    fmt.Println("End")
```

# å¾ªç¯è¯­å¥
```go
// for
for i := 0; i < 10; i++ {
    fmt.Println(i)
}
for i < 10 { // ç›¸å½“äº while
    fmt.Println(i)
    i++
}
for { // ç›¸å½“äº loop
    fmt.Println(i)
    i++
    if i == 10 {
        break
    }
}

// range
arr := []int{1, 2, 3}
for index, value := range arr {
    fmt.Printf("index: %d, value: %d\n", index, value)
}

// break, continue
for i := 1; i != 0; i++ {
    if i <= 5 {
        continue
    }
    if i >= 10 {
        break
    }
    fmt.Println(i)
} // 6, 7, 8, 9

// é€šè¿‡æ ‡ç­¾è¯­å¥è·³å‡ºå¤šå±‚å¾ªç¯
end:
    for i := 0; i < 10; i++ {
        for j := 0; j < 10; j++ {
            if i == 5 && j == 5 {
                break end
            }
            fmt.Println(i, j)
        }
    }    
```

# æ•°ç»„å’Œåˆ‡ç‰‡
`Go` ä¸­çš„æ•°ç»„æ˜¯å€¼ç±»å‹, ä½œä¸ºå‚æ•°ä¼ é€’æ—¶ä¼šæ‹·è´ä¸€ä»½, ä½†æ˜¯åˆ‡ç‰‡æ˜¯å¼•ç”¨ç±»å‹, ä¼ é€’æ—¶åªä¼šä¼ é€’æŒ‡é’ˆ

```go
// æ•°ç»„
var arr [3]int
arr[0] = 1
arr[1] = 2
fmt.Println(arr) // [1 2 0]
fmt.Println(len(arr)) // 3
fmt.Println(cap(arr)) // 3, å¯¹äºæ•°ç»„æ¥è¯´, å®¹é‡å’Œé•¿åº¦ç›¸åŒ

// åˆ‡ç‰‡
slice := []int{1, 2, 3, 4, 5}
fmt.Println(slice) // [1 2 3 4 5]
fmt.Println(slice[1:3]) // [2 3], å·¦é—­å³å¼€
fmt.Println(slice[:3]) // [1 2 3], ä»å¤´å¼€å§‹
fmt.Println(slice[3:]) // [4 5], åˆ°å°¾ç»“æŸ
fmt.Println(len(slice)) // 5

slice := make([]int, 3, 5) // åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º 3, å®¹é‡ä¸º 5 çš„åˆ‡ç‰‡
fmt.Println(slice) // [0 0 0]
fmt.Println(len(slice)) // 3
fmt.Println(cap(slice)) // 5

// æ·»åŠ å…ƒç´ 
slice = append(slice, 1, 2, 3)
fmt.Println(slice) // [0 0 0 1 2 3]
// ä»å¤´æ·»åŠ 
slice = append([]int{1, 2, 3}, slice...) // å±•å¼€è¿ç®—ç¬¦ ...
fmt.Println(slice) // [1 2 3 0 0 0 1 2 3]
// ä» i ä½ç½®æ·»åŠ 
slice = append(slice[:i+1], append([]int{1, 2, 3}, slice[i+1:]...)...)
fmt.Println(slice) // [1 2 3 0 1 2 3 0 0 0 1 2 3]

// åˆ é™¤å…ƒç´ 
slice = slice[:5] // åˆ é™¤å°¾éƒ¨å…ƒç´ 
fmt.Println(slice) // [1 2 3 0 1]
slice = slice[1:] // åˆ é™¤å¤´éƒ¨å…ƒç´ 
fmt.Println(slice) // [2 3 0 1]
slice = append(slice[:i], slice[i+1:]...) // åˆ é™¤ä¸­é—´å…ƒç´ 
fmt.Println(slice) // [2 3 1]
slice = slice[:0] // æ¸…ç©ºåˆ‡ç‰‡
// æˆ– clear(slice)
fmt.Println(slice) // []

// å¤åˆ¶åˆ‡ç‰‡
oldSlice := []int{1, 2, 3}
newSlice := make([]int, len(oldSlice))
copy(newSlice, oldSlice)

// å¤šç»´åˆ‡ç‰‡
slice := [][]int{{1, 2}, {3, 4}}
fmt.Println(slice) // [[1 2] [3 4]]
```

#### æ‹“å±•è¡¨è¾¾å¼
![](/images/note/go-tzbds.png)

```go
func main() {
   s1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9} // cap = 9
   s2 := s1[3:4:4]                        // cap = 4 - 3 = 1
   // å®¹é‡ä¸è¶³ï¼Œåˆ†é…æ–°çš„åº•å±‚æ•°ç»„
   s2 = append(s2, 1)
   fmt.Println(s2) // [4 1]
   fmt.Println(s1) // [1 2 3 4 5 6 7 8 9]
}
```

# å­—ç¬¦ä¸²
`Go` ä¸­çš„å­—ç¬¦ä¸²çš„æœ¬è´¨æ˜¯ `[n]byte`, å¯ä»¥ä½¿ç”¨æ•°ç»„å’Œåˆ‡ç‰‡çš„æ–¹å¼è¿›è¡Œæ“ä½œ

```go
str := "Hello, World!"
fmt.Println(str[0]) // 72, ASCII ç 
fmt.Println(string(str[0])) // H
fmt.Println(string(str[0:5])) // Hello
// ä¸èƒ½ç›´æ¥ä¿®æ”¹å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦
str[0] = 'h' // æŠ¥é”™
str = "hello" // æ­£ç¡®

// è½¬ä¸º []byte
byteStr := []byte(str)
fmt.Println(byteStr) // [104 101 108 108 111]
fmt.Println(string(byteStr)) // hello
// å¯ä»¥ä¿®æ”¹ []byte ä¸­çš„å­—ç¬¦
byteStr[0] = 'H'
byteStr = append(byteStr, []byte(" World!")...)
fmt.Println(string(byteStr)) // Hello World!
fmt.Println(len(byteStr)) // 12
// æ³¨æ„: ä¸€ä¸ªä¸­æ–‡å­—ç¬¦å  3 ä¸ªå­—èŠ‚

// æ‹·è´
oldStr := "Hello"
newStr := make([]byte, len(oldStr))
copy(newStr, oldStr)
// æˆ–è€…
newStr = strings.Clone(oldStr)

// å­—ç¬¦ä¸²æ‹¼æ¥
str1 := "Hello"
str2 := "World"
str3 := str1 + " " + str2
// é«˜æ€§èƒ½æ‹¼æ¥
builder := strings.Builder{}
builder.WriteString(str1)
builder.WriteString(" ")
builder.WriteString(str2)
str3 = builder.String()
```

> è¦éå†æ‰“å°å­—ç¬¦ä¸²ä¸­çš„ `Unicode` å­—ç¬¦, éœ€è¦æ ¼å¼åŒ–ä¸º `rune` ç±»å‹ (`%c`)

# æ˜ å°„
`Go` ä¸­çš„æ˜ å°„æ˜¯æ— åºçš„é”®å€¼å¯¹é›†åˆ, é”®å€¼å¯¹çš„ç±»å‹å¯ä»¥æ˜¯ä»»æ„ç±»å‹, ä½†æ˜¯**é”®å¿…é¡»æ˜¯å¯ä»¥æ¯”è¾ƒçš„ç±»å‹**, å¦‚ `int`, `string`, `float`, `struct` ç­‰

`Go` ä¸­æ²¡æœ‰ `set` ç±»å‹, å¯ä»¥ç”¨ `map[T]struct{}` æ¥æ¨¡æ‹Ÿ, `struct{}` æ˜¯ä¸€ä¸ªç©ºç»“æ„ä½“, ä¸å ç”¨å†…å­˜

`map` ä¸æ˜¯å¹¶å‘å®‰å…¨çš„, å¦‚æœéœ€è¦çº¿ç¨‹å®‰å…¨, å¯ä»¥ä½¿ç”¨ `sync.Map`

```go
// åˆ›å»º
m := make(map[string]int, 10) // åˆ›å»ºä¸€ä¸ªå®¹é‡ä¸º 10 çš„æ˜ å°„
m := map[string]int{"a": 1, "b": 2} // åˆ›å»ºå¹¶åˆå§‹åŒ–

// è®¿é—®
fmt.Println(m["a"]) // 1
fmt.Println(m["c"]) // 0, ä¸å­˜åœ¨çš„é”®è¿”å›é›¶å€¼
fmt.Println(len(m)) // 2
// å®é™…ä¸Šæœ‰ä¸¤ä¸ªè¿”å›å€¼, ç¬¬äºŒä¸ªè¿”å›å€¼è¡¨ç¤ºæ˜¯å¦å­˜åœ¨
value, exists := m["c"] // 0, false

// æ·»åŠ 
m["c"] = 3

// åˆ é™¤
delete(m, "c")

// éå†
for key, value := range m {
    fmt.Printf("key: %s, value: %d\n", key, value)
}

// æ¸…ç©º
for key := range m {
    delete(m, key)
}
// æˆ–
clear(m) // go1.21+
```

> å½“é”®ä¸º `math.NaN()` æ—¶, ç”±äº `NaN` ä¸ç­‰äºè‡ªèº«, æ‰€ä»¥å¯ä»¥æœ‰å¤šä¸ª `NaN` é”® (å…¶åº•å±‚ç”±æ±‡ç¼–æŒ‡ä»¤ `UCOMISD` å®ç°); åº”é¿å…ç”¨ `math.NaN()` ä½œä¸ºé”®

# æŒ‡é’ˆ
`Go` ä¸­çš„æŒ‡é’ˆæ˜¯ä¸€ä¸ªå˜é‡, å…¶å€¼ä¸ºå¦ä¸€ä¸ªå˜é‡çš„åœ°å€, ç”¨äºå­˜å‚¨å˜é‡çš„å†…å­˜åœ°å€; **`Go` ä¸­çš„æŒ‡é’ˆä¸èƒ½è¿›è¡Œè¿ç®—**

```go
num := 1
// è·å–å˜é‡çš„åœ°å€
var pointer *int = &num // æˆ– pointer := &num
fmt.Println(pointer) // 0xc0000b0008
// è·å–æŒ‡é’ˆæŒ‡å‘çš„å€¼
fmt.Println(*pointer) // 1

// åˆ›å»ºä¸€ä¸ªæŒ‡å‘ç‰¹å®šç±»å‹é›¶å€¼çš„æŒ‡é’ˆ
pointer := new(int)
fmt.Println(*pointer) // 0
```

#### new & make
| | `new` | `make` |
| :---: | :---: | :---: |
| è¯­æ³• | `pointer := new(T)` | `slice := make([]T, len, cap)` |
| è¿”å›å€¼ | `*T` | `T` |
| å‚æ•° | ç±»å‹ | ç±»å‹, å‰©ä½™å‚æ•°ç”±ç±»å‹å†³å®š |
| ç”¨é€” | ç»™æŒ‡é’ˆåˆ†é…å†…å­˜ | ç»™åˆ‡ç‰‡ã€æ˜ å°„ã€é€šé“åˆ†é…å†…å­˜ |

# ç»“æ„ä½“
`Go` æŠ›å¼ƒäº†ç±»ä¸ç»§æ‰¿ï¼ŒåŒæ—¶ä¹ŸæŠ›å¼ƒäº†æ„é€ æ–¹æ³•ï¼Œåˆ»æ„å¼±åŒ–äº†é¢å‘å¯¹è±¡çš„åŠŸèƒ½ï¼Œ`Go` å¹¶éæ˜¯ä¸€ä¸ªé¢å‘å¯¹è±¡çš„è¯­è¨€ï¼Œä½†æ˜¯ `Go` ä¾æ—§æœ‰ç€é¢å‘å¯¹è±¡çš„å½±å­ï¼Œé€šè¿‡ç»“æ„ä½“å’Œæ–¹æ³•ä¹Ÿå¯ä»¥æ¨¡æ‹Ÿå‡ºä¸€ä¸ªç±»

```go
// å®šä¹‰
type Person struct {
    Name string
    Age int
    Hobby []string
    secret string // ç§æœ‰å­—æ®µ
}
type CutePerson struct {
    Person // åŒ¿åå­—æ®µ
    IsCute bool
}

// åˆ›å»º
p := Person{"å°å¶å­", 18, []string{"Reading", "Painting"}, "Won't tell you"} // å¿…é¡»æŒ‰é¡ºåºåˆå§‹åŒ–æ‰€æœ‰å­—æ®µ
p := Person{
    Name: "å°å¶å­",
    Age: 18,
} // æœªåˆå§‹åŒ–çš„å­—æ®µä¸ºé›¶å€¼
// ä¹Ÿå¯ä»¥æ‰‹åŠ¨ç¼–å†™æ„é€ å‡½æ•° (å·¥å‚æ–¹æ³•)

// è®¿é—®
fmt.Println(p.Name) // å°å¶å­
fmt.Println(p.secret) // æŠ¥é”™

// ç»“æ„ä½“æŒ‡é’ˆä¼šè‡ªåŠ¨è§£å¼•ç”¨
p := &Person{"å°å¶å­", 18, []string{"Reading", "Painting"}, "Won't tell you"}
fmt.Println(p.Name) // å°å¶å­
```

# å‡½æ•°
{% notel green æœ¬æ®µå†…å®¹ %}
{% btn å¯å˜å‚æ•°::#å¯å˜å‚æ•° %} {% btn åŒ¿åå‡½æ•°::#åŒ¿åå‡½æ•° %} {% btn é—­åŒ…::#é—­åŒ… %} {% btn `defer`::#defer %}
{% endnotel %}

`Go` ä¸­çš„å‡½æ•°æ˜¯ä¸€ç­‰å…¬æ°‘, å¯ä»¥ä½œä¸ºå‚æ•°ä¼ é€’, ä¹Ÿå¯ä»¥ä½œä¸ºè¿”å›å€¼

```go
// å®šä¹‰
func NameOfFunction(param1 type1, param2 type2) returnType {
    // å‡½æ•°ä½“
    return value
}
// å‡½æ•°è¡¨è¾¾å¼
var funcName = func(param1 type1, param2 type2) (returnType1, returnType2) {
    // å‡½æ•°ä½“
    return value1, value2
}
// ç±»å‹
type FuncType func(param1 type1, param2 type2) returnType

// ç»™è¿”å›å€¼å‘½å
func Add(a, b int) (ans int) {
    ans := a + b
    return // ç­‰ä»·äº return ans
}
```

#### å¯å˜å‚æ•°
```go
func sum(args ...int) int {
    sum := 0
    for _, value := range args {
        sum += value
    }
    return sum
}
```

#### åŒ¿åå‡½æ•°
åŒ¿åå‡½æ•°åªèƒ½åœ¨å‡½æ•°å†…éƒ¨å®šä¹‰, ä½†æ˜¯å¯ä»¥ä½œä¸ºè¿”å›å€¼

```go
func main() {
    func(a, b int) {
        fmt.Println(a + b)
    }(1, 2)

    // å›è°ƒå‡½æ•°
    func addadd(callback func(int, int) int, c int) {
        fmt.Println(callback(1, 2) + c)
    }
    addadd(func(a, b int) int {
        return a + b
    }, 3)
}
```

#### é—­åŒ…
```go
func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}
func main() {
    add := adder()
    fmt.Println(add(1)) // 1
    fmt.Println(add(2)) // 3
}
```

#### defer
`defer` è¯­å¥ä¼šå»¶è¿Ÿå‡½æ•°çš„æ‰§è¡Œ, ç›´åˆ°åŒ…å« `defer` è¯­å¥çš„å‡½æ•°æ‰§è¡Œå®Œæ¯•åå†æ‰§è¡Œ; **é€šå¸¸ç”¨äºé‡Šæ”¾èµ„æºã€å…³é—­æ–‡ä»¶ã€è§£é”ç­‰**, å¯ä»¥å†™åœ¨å¼€å¯ä»»åŠ¡çš„åé¢, ä½¿ä»£ç æ›´åŠ æ¸…æ™°

å½“æœ‰å¤šä¸ª `defer` è¯­å¥æ—¶, å…¶æ‰§è¡Œé¡ºåºæ˜¯**åè¿›å…ˆå‡º**çš„

```go
func main() {
    defer fmt.Println("World")
    fmt.Println("Hello")
}
```

##### æ³¨æ„äº‹é¡¹
åº”å½“é¿å…åœ¨ `defer` è¯­å¥ä¸­ä½¿ç”¨ä½¿ç”¨å‡½æ•°è¿”å›å€¼ä½œä¸ºå‚æ•°

```go
func main() {
    defer fmt.Println(f())
    fmt.Println('3')
}
func f() int {
    fmt.Println('2')
    return '1'
}
// é¢„æœŸè¾“å‡º: 3 2 1
// å®é™…è¾“å‡º: 2 3 1
```

# æ–¹æ³•
`Go` ä¸­çš„æ–¹æ³•æ˜¯ä¸€ç§ç‰¹æ®Šçš„å‡½æ•°, å…¶æ¥æ”¶è€…æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰ç±»å‹, å¯ä»¥ç†è§£ä¸ºç±»çš„æ–¹æ³•

```go
type Person struct {
    Name string
    Age int
}

func (p Person) Say() { // (p Person) ä¸ºæ¥æ”¶è€…
    fmt.Println("Hello, I'm", p.Name)
}
func (p *Person) Grow() { // æŒ‡é’ˆæ¥æ”¶è€…, å¯ä»¥ä¿®æ”¹æ¥æ”¶è€…çš„å€¼
    p.Age++
}

p := Person{"å°å¶å­", 18}
p.Say() // Hello, I'm å°å¶å­
p.Grow()
fmt.Println(p.Age) // 19
// æ–¹æ³•åªèƒ½é€šè¿‡æ¥æ”¶è€…è°ƒç”¨, ä¸èƒ½ç›´æ¥è°ƒç”¨
```

> å‡½æ•°ä¼ å‚æ—¶, ä¼šè¿›è¡Œå€¼æ‹·è´, æ‰€ä»¥**æ¨èä½¿ç”¨æŒ‡é’ˆæ¥æ”¶è€…**, ä»¥å‡å°‘å†…å­˜å¼€é”€

# æ¥å£
`Go` ä¸­çš„æ¥å£æ˜¯ä¸€ç§æŠ½è±¡ç±»å‹, å®šä¹‰äº†ä¸€ç»„æ–¹æ³•, ä½†æ˜¯æ²¡æœ‰å…·ä½“å®ç°, åªè¦å®ç°äº†æ¥å£ä¸­çš„æ‰€æœ‰æ–¹æ³•, å°±å¯ä»¥ç§°ä¸ºè¯¥æ¥å£çš„å®ç°

```go
// å®šä¹‰
type Animal interface {
    Eat(string) string
    Sleep() string
}

// å®ç°
type Cat struct {
    Name string
}
func (c *Cat) Eat(food string) string {
    return c.Name + " is eating " + food
}
func (c *Cat) Sleep() string {
    return c.Name + " is sleeping"
}

// ä½¿ç”¨
func main() {
    // ç”±äº Cat å®ç°äº† Animal, æ‰€ä»¥å¯ä»¥å°† Cat èµ‹å€¼ç»™ Animal
    var animal Animal = &Cat{"Tom"}
    fmt.Println(animal.Eat("fish")) // Tom is eating fish
    fmt.Println(animal.Sleep()) // Tom is sleeping
}
```

> æ¥å£æ˜¯ä¸€ç§éšå¼å®ç°, åªè¦å®ç°äº†æ¥å£ä¸­çš„æ‰€æœ‰æ–¹æ³•, å°±å¯ä»¥ç§°ä¸ºè¯¥æ¥å£çš„å®ç°, æ— éœ€æ˜¾å¼ `implements`

# æ³›å‹
```go
// å‡½æ•°å‚æ•°
func Add[T int | float](a, b T) T {
    return a + b
}
fmt.Println(Add(1, 2)) // è‡ªåŠ¨æ¨æ–­
fmt.Println(Add[float](1.1, 2.2)) // æ˜¾å¼æŒ‡å®š

// åˆ‡ç‰‡
type Slice[T any] []T
slice := Slice[int]{1, 2, 3} // å¿…é¡»æ˜¾å¼æŒ‡å®šæ³›å‹ç±»å‹

// æ˜ å°„
type Map[K comparable, V any] map[K]V
m := Map[string, int]{"a": 1, "b": 2}

// ç»“æ„ä½“
type Pair[T any] struct {
    First, Second T
}
```

> `any` è¡¨ç¤ºä»»æ„ç±»å‹, å®è´¨æ˜¯ `interface{}` çš„åˆ«å, `comparable` è¡¨ç¤ºå¯æ¯”è¾ƒçš„ç±»å‹; åŒ¿åç»“æ„ä½“ä¸æ”¯æŒæ³›å‹ã€åŒ¿åå‡½æ•°ä¸æ”¯æŒè‡ªå®šä¹‰æ³›å‹

#### ç±»å‹é›†
ç±»å‹é›†æ˜¯ä¸€ç§æ³›å‹çº¦æŸ, ç”¨äºé™åˆ¶æ³›å‹ç±»å‹çš„èŒƒå›´, **åªèƒ½ç”¨äºçº¦æŸæ³›å‹, ä¸èƒ½ç”¨ä½œç±»å‹å®å‚**

```go
type SignedInteger interface {
    int | int8 | int16 | int32 | int64
}
type UnsignedInteger interface {
    uint | uint8 | uint16 | uint32 | uint64
}
type Integer interface {
    SignedInteger | UnsignedInteger
}

func Add[T Integer](a, b T) T {
    return a + b
}
```

# é”™è¯¯
{% notel green æœ¬æ®µå†…å®¹ %}
{% btn `panic`::#panic %} {% btn `fatal`::#fatal %}
{% endnotel %}

`Go` ä¸­çš„é”™è¯¯æ˜¯ä¸€ä¸ªæ¥å£, åªè¦å®ç°äº† `Error() string` æ–¹æ³•, å°±å¯ä»¥ç§°ä¸ºé”™è¯¯

`Go` æ²¡æœ‰ `try catch` è¯­å¥, é€šè¿‡è¿”å›å€¼æ¥å¤„ç†é”™è¯¯, å¦‚ `if err != nil { return err }`

```go
// åˆ›å»º
import (
    "errors"
    "fmt"
)
err := errors.New("This is an error")
err := fmt.Errorf("This is an error: %s", "error")
func f() (int, error) {
    return 0, errors.New("This is an error")
}
// ä¸ºäº†æ›´å¥½çš„ç»´æŠ¤æ€§, ä¸€èˆ¬ä¼šå°†å¸¸ç”¨é”™è¯¯å®šä¹‰ä¸ºå…¨å±€å˜é‡

// è‡ªå®šä¹‰é”™è¯¯
type MyError struct {
    Msg string
}
func (e *MyError) Error() string {
    return e.Msg
}
```

#### panic
`panic` ç”¨äºå¼•å‘ä¸€ä¸ªè¿è¡Œæ—¶é”™è¯¯, ä¼šå¯¼è‡´ç¨‹åºå´©æºƒ, ä½†æ˜¯å¯ä»¥é€šè¿‡ `recover` æ¥æ•è· `panic` å¼•å‘çš„é”™è¯¯

ç¨‹åºé€€å‡ºå‰ä¼šæ‰§è¡Œæ‰€æœ‰ `defer` è¯­å¥, æ‰€ä»¥å¯ä»¥åœ¨ `defer` è¯­å¥ä¸­ä½¿ç”¨ `recover` æ¥æ•è· `panic`

```go
info := ""

defer func() {
    if err := recover(); err != nil {
        fmt.Println("panic error:", err)
    }
}()

if info == "" {
    panic("info is empty")
}
```

#### fatal
`fatal` ç”¨äºå¼•å‘ä¸€ä¸ªè‡´å‘½é”™è¯¯, ä¼šå¯¼è‡´ç¨‹åºå´©æºƒ, ä¸ä¼šæ‰§è¡Œ `defer` è¯­å¥

```go
import "os"

if info == "" {
    fmt.Println("info is empty")
    os.Exit(1)
}
```

> ä¸€èˆ¬ä¸ä¼šä¸»åŠ¨è§¦å‘ `fatal`, é€šå¸¸æ˜¯ç”±äºç³»ç»Ÿé”™è¯¯å¯¼è‡´

# æ–‡ä»¶
`Go` ä¸­çš„äºŒè¿›åˆ¶æ•°æ®æ˜¯ä»¥ `[]byte` çš„å½¢å¼å­˜å‚¨çš„ (ç±»ä¼¼äº `JavaScript` ä¸­çš„ `Uint8Array`)

å¸¸ç”¨çš„æ–‡ä»¶æ“ä½œå¯ä»¥ä½¿ç”¨ `os` åŒ…å®ç°

## æ‰“å¼€
| å‡½æ•° | æè¿° |
| :---: | :---: |
| `os.Open(name string) (*File, error)` | æ‰“å¼€æ–‡ä»¶, åªè¯», å®è´¨æ˜¯ `os.OpenFile(name, os.O_RDONLY, 0)` |
| `os.OpenFile(name string, flag int, perm FileMode) (*File, error)` | æ‰“å¼€æ–‡ä»¶, å¯ä»¥æŒ‡å®šæ‰“å¼€æ–¹å¼å’Œæƒé™ |
| `os.IsNotExist(err error) bool` | åˆ¤æ–­é”™è¯¯æ˜¯å¦ä¸ºæ–‡ä»¶ä¸å­˜åœ¨ |
| `os.Lstat(name string) (FileInfo, error)` | è·å–æ–‡ä»¶ä¿¡æ¯ |
| `file.Close() error` | **å…³é—­æ–‡ä»¶, é€šå¸¸é…åˆ `defer` ä½¿ç”¨** |
| `os.Create(name string) (*File, error)` | åˆ›å»ºæ–‡ä»¶, å®è´¨æ˜¯ `os.OpenFile(name, os.O_RDWR\|os.O_CREATE\|os.O_TRUNC, 0666)`, ä¸æ”¯æŒé€’å½’åˆ›å»ºç›®å½• |

```go
import (
    "os"
    "fmt"
)

// æ‰“å¼€æ–‡ä»¶
file, err := os.Open("file.txt")
if os.IsNotExist(err) {
    fmt.Println("file not exist")
} else if err != nil {
    fmt.Println(err)
} else {
    fmt.Println("file opened")
    defer file.Close()
}
```

#### æ¨¡å¼
| æ¨¡å¼ | æè¿° |
| :---: | :---: |
| `os.O_RDONLY` | åªè¯» |
| `os.O_WRONLY` | åªå†™ |
| `os.O_RDWR` | è¯»å†™ |
| `os.O_APPEND` | è¿½åŠ  |
| `os.O_CREATE` | ä¸å­˜åœ¨åˆ™åˆ›å»º |
| `os.O_TRUNC` | æ‰“å¼€æ—¶æ¸…ç©º |

> å‰ä¸‰ä¸ªæ¨¡å¼å¿…é¡»æŒ‡å®šå…¶ä¸€, åé¢çš„æŒ‰éœ€é€‰æ‹©

## è¯»å–
| å‡½æ•° | æè¿° |
| :---: | :---: |
| `file.Read(p []byte) (n int, err error)` | è¯»å–æ–‡ä»¶å†…å®¹åˆ° `[]byte` ä¸­ |
| `os.ReadFile(name string) ([]byte, error)` | è¯»å–æ–‡ä»¶å†…å®¹åˆ° `[]byte` ä¸­ |

```go
// file.Read
import (
    "os"
    "fmt"
)

file, _ := os.Open("file.txt")
defer file.Close()

// å®šä¹‰ä¸€ä¸ªåŠ¨æ€æ‰©å®¹çš„åˆ‡ç‰‡é€»è¾‘
func ReadText(file *os.File) string {
    buf := make([]byte, 0, 1024)
    for {
        // å¦‚æœåˆ‡ç‰‡å®¹é‡ä¸è¶³, åˆ™æ‰©å®¹
        if len(buf) == cap(buf) {
            buf = append(buf, make([]byte, 1024)...)
        }
        // è¯»å–æ–‡ä»¶å†…å®¹, ç›´åˆ°æ–‡ä»¶æœ«å°¾ (è¶…å‡ºåˆ‡ç‰‡å®¹é‡çš„éƒ¨åˆ†ä¼šè¢«ä¸¢å¼ƒ)
        // n ä¸ºè¯»å–åˆ°çš„å­—èŠ‚æ•°
        n, err := file.Read(buf[len(buf):cap(buf)])
        // å¦‚æœè¯»å–åˆ°æ–‡ä»¶æœ«å°¾, åˆ™é€€å‡º
        if err == io.EOF {
            // ä»åˆ‡ç‰‡ä¸­æˆªå–æœ‰æ•ˆéƒ¨åˆ†
            buf = buf[:len(buf)+n]
            break
        } else if err != nil {
            fmt.Println(err)
            break
        }
    }
    return string(buf)
}

fmt.Println(ReadText(file))
```

```go
// os.ReadFile
import (
    "os"
    "fmt"
)

data, err := os.ReadFile("file.txt")
if err != nil {
    fmt.Println(err)
} else {
    fmt.Println(string(data))
}
```

## å†™å…¥
| å‡½æ•° | æè¿° |
| :---: | :---: |
| `file.Write(p []byte) (n int, err error)` | å†™å…¥ `[]byte` åˆ°æ–‡ä»¶ä¸­ |
| `file.WriteString(s string) (n int, err error)` | å†™å…¥å­—ç¬¦ä¸²åˆ°æ–‡ä»¶ä¸­ |
| `os.WriteFile(name string, data []byte, perm FileMode) error` | å†™å…¥ `[]byte` åˆ°æ–‡ä»¶ä¸­ |
| `io.WriteString(w Writer, s string) (n int, err error)` | å†™å…¥å­—ç¬¦ä¸²åˆ° `Writer` ä¸­ |

```go
// file.WriteString
import (
    "os"
    "fmt"
)

file, _ := os.OpenFile("file.txt", os.O_RDWR|os.O_APPEND|os.O_CREATE|os.O_TRUNC, 0666)
defer file.Close()

for i := 0; i < 10; i++ {
    offset, err := file.WriteString("Hello, World!\n")
    if err != nil {
        fmt.Println(err, offset)
        break
    }
}
```

```go
// os.WriteFile
import (
    "os"
    "fmt"
)

data := []byte("Hello, World!\n")
err := os.WriteFile("file.txt", data, 0666)
if err != nil {
    fmt.Println(err)
}
```

```go
// io.WriteString
import (
    "os"
    "io"
    "fmt"
)

file, _ := os.OpenFile("file.txt", os.O_RDWR|os.O_APPEND|os.O_CREATE|os.O_TRUNC, 0666)
defer file.Close()

for i := 0; i < 10; i++ {
    offset, err := io.WriteString(file, "Hello, World!\n")
    if err != nil {
        fmt.Println(err, offset)
        break
    }
}
```

## å¤åˆ¶
| å‡½æ•° | æè¿° |
| :---: | :---: |
| `file.ReadFrom(r io.Reader) (n int64, err error)` | ä» `io.Reader` ä¸­è¯»å–å†…å®¹åˆ°æ–‡ä»¶ä¸­ |
| `io.Copy(dst Writer, src Reader) (written int64, err error)` | å¤åˆ¶ `Reader` åˆ° `Writer` ä¸­ |

```go
// file.ReadFrom
import (
    "os"
    "fmt"
)

src, _ := os.Open("file.txt")
defer src.Close()
dst, _ := os.Create("file_copy.txt")
defer dst.Close()

n, err := dst.ReadFrom(src)
if err != nil {
    fmt.Println(err)
} else {
    fmt.Println(n)
}
```

```go
// io.Copy
import (
    "os"
    "io"
    "fmt"
)

src, _ := os.Open("file.txt")
defer src.Close()
dst, _ := os.Create("file_copy.txt")
defer dst.Close()

n, err := io.Copy(dst, src)
if err != nil {
    fmt.Println(err)
} else {
    fmt.Println(n)
}
```

## å…¶ä»–
| å‡½æ•° | æè¿° |
| :---: | :---: |
| `os.Rename(oldpath, newpath string) error` | ç§»åŠ¨æ–‡ä»¶æˆ–ç›®å½• |
| `os.Remove(name string) error` | åˆ é™¤æ–‡ä»¶æˆ–ç©ºç›®å½• |
| `os.RemoveAll(name string) error` | é€’å½’åˆ é™¤ç›®å½•åŠå…¶å­ç›®å½• |
| `os.ReadDir(name string) ([]DirEntry, error)` | è¯»å–ç›®å½•å†…å®¹ |
| `file.Readdir(n int) ([]DirEntry, error)` | `n < 0` è¯»å–å…¨éƒ¨, `n > 0` è¯»å– `n` ä¸ª<br>æ˜¯ `os.ReadDir` çš„åº•å±‚åŸç† |
| `os.Mkdir(name string, perm FileMode) error` | åˆ›å»ºç›®å½• |
| `os.MkdirAll(path string, perm FileMode) error` | é€’å½’åˆ›å»ºç›®å½• |
| `filepath.Walk(dir string, walkFn WalkFunc) error` | é€’å½’éå†ç›®å½• |

```go
// å°è£…ä¸€ä¸ª CopyDir å‡½æ•°
import (
    "os"
    "io"
    "fmt"
    "path/filepath"
)

func CopyDir(src, dst string) error {
    // æ£€æŸ¥æºç›®å½•å’Œç›®æ ‡ç›®å½•çŠ¶æ€
    srcInfo, err := os.Stat(src)
    if err != nil {
        return err
    }
    if !srcInfo.IsDir() {
        return fmt.Errorf("%s is not a directory", src)
    }
    dstInfo, err := os.Stat(dst)
    if err != nil {
        if os.IsNotExist(err) {
            os.MkdirAll(dst, srcInfo.Mode())
        } else {
            return err
        }
    } else if !dstInfo.IsDir() {
        return fmt.Errorf("%s is not a directory", dst)
    }
    
    return filepath.Walk(src, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        // è·å–ç›¸å¯¹è·¯å¾„
        relPath, err := filepath.Rel(src, path)
        if err != nil {
            return err
        }
        // æ‹¼æ¥ç›®æ ‡è·¯å¾„
        dstPath := filepath.Join(dst, relPath)
        // å¦‚æœæ˜¯ç›®å½•, åˆ™åˆ›å»ºç›®å½•
        if info.IsDir() {
            return os.MkdirAll(dstPath, info.Mode())
        // å¦‚æœæ˜¯æ–‡ä»¶, åˆ™å¤åˆ¶æ–‡ä»¶
        } else {
            srcFile, err := os.Open(path)
            if err != nil {
                return err
            }
            defer srcFile.Close()
            dstFile, err := os.Create(dstPath)
            if err != nil {
                return err
            }
            defer dstFile.Close()
            // å¤åˆ¶æ–‡ä»¶
            _, err = io.Copy(dstFile, srcFile)
            return err
        }
    })
}
```

# ğŸš§åå°„

# å¹¶å‘
`Go` é€šè¿‡ `goroutine` å®ç°å¹¶å‘, `goroutine` æ˜¯ä¸€ç§è½»é‡çº§çš„çº¿ç¨‹, ç”± `Go` è¿è¡Œæ—¶ç®¡ç†; é€šè¿‡ `go` å…³é”®å­—åè·Ÿä¸€ä¸ªå‡½æ•°**è°ƒç”¨**æ¥å¿«é€Ÿåˆ›å»ºä¸€ä¸ª `goroutine`

`goroutine` çš„è¡Œä¸ºç±»ä¼¼äº `JavaScript` ä¸­çš„ `Promise`, å¦‚æœä¸åŠ ä»¥æ§åˆ¶, å¯èƒ½ä¼šå¯¼è‡´ç¨‹åºçš„ä¸»çº¿ç¨‹æå‰ç»“æŸ

è¦æ§åˆ¶ `goroutine`, å¯ä»¥ä½¿ç”¨ `sync.WaitGroup` æ¥ç­‰å¾…æ‰€æœ‰ `goroutine` å®Œæˆ (ç±»ä¼¼äº `Promise.all`); è¿˜å¯ä»¥ä½¿ç”¨ `channel` æ¥è¿›è¡Œé€šä¿¡; ä»¥åŠ `context` æ¥æ§åˆ¶ `goroutine` çš„ç”Ÿå‘½å‘¨æœŸ

```go
import (
    "fmt"
    "sync"
)

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            fmt.Println(i)
        }(i)
    }
    wg.Wait()
}
```

## channel
{% notel green æœ¬æ®µå†…å®¹ %}
{% btn åŠ è§£é”æ“ä½œ::#åŠ è§£é”æ“ä½œ %} {% btn å•å‘ç®¡é“::#å•å‘ç®¡é“ %} {% btn éå†ç®¡é“::#éå†ç®¡é“ %}
{% endnotel %}

`channel` æ˜¯ `Go` ä¸­çš„ä¸€ç§æ•°æ®ç»“æ„, ç”¨äºåœ¨ `goroutine` ä¹‹é—´ä¼ é€’æ•°æ®, æ˜¯ä¸€ç§**çº¿ç¨‹å®‰å…¨**çš„é˜Ÿåˆ—

å¿…é¡»ä½¿ç”¨ `make` åˆ›å»º `channel`, `channel` æœ‰ä¸¤ç§ç±»å‹: `unbuffered` (åŒæ­¥çš„) å’Œ `buffered` (å¼‚æ­¥çš„), åˆ†åˆ«å¯¹åº” `make(chan T)` å’Œ `make(chan T, n)` (å…¶ä¸­ `n` ä¸ºç¼“å†²åŒºå¤§å°)

å¯¹äºæ— ç¼“å†² `channel`, å‘é€å’Œæ¥æ”¶æ“ä½œæ˜¯åŒæ­¥çš„, å‘é€æ“ä½œä¼šé˜»å¡, ç›´åˆ°æœ‰å…¶ä»– `goroutine` æ¥æ”¶æ•°æ®; æ¥æ”¶æ“ä½œä¹Ÿä¼šé˜»å¡, ç›´åˆ°æœ‰å…¶ä»– `goroutine` å‘é€æ•°æ® (ç±»ä¼¼äº `await`)

å¯¹äºæœ‰ç¼“å†² `channel`, å‘é€æ“ä½œä¸ä¼šé˜»å¡, é™¤éç¼“å†²åŒºæ»¡; æ¥æ”¶æ“ä½œä¹Ÿä¸ä¼šé˜»å¡, é™¤éç¼“å†²åŒºç©º

åŒæ ·å¯ä»¥é€šè¿‡ `len` å’Œ `cap` å‡½æ•°è·å– `channel` çš„é•¿åº¦å’Œå®¹é‡

```go
import (
    "fmt"
)

func main() {
    ch := make(chan int, 1)
    defer close(ch) // å…³é—­ channel

    go func() {
        ch <- 123 // å°†æ•°æ®å‘é€åˆ° channel
        // æ­¤æ—¶å¦‚æœæ˜¯æ— ç¼“å†² channel, åˆ™ä¼šé˜»å¡
    }()

    data := <- ch // ä» channel ä¸­æ¥æ”¶æ•°æ®
    fmt.Println(data)
}
```

#### åŠ è§£é”æ“ä½œ
é€šè¿‡ä¸€ä¸ªç¼“å†²åŒºä¸º `1` çš„ `channel` æ¥å®ç°åŠ è§£é”æ“ä½œ

```go
lock := make(chan struct{}, 1)

func FetchData() {
    // åŠ é”, å¦‚æœ channel ä¸­æœ‰æ•°æ®, åˆ™ä¼šé˜»å¡ç­‰å¾…
    lock <- struct{}{}
    defer func() {
        // è§£é”
        <- lock
    }()
    // è·å–æ•°æ®
    // ...
}    
```

#### å•å‘ç®¡é“
`channel` å¯ä»¥é€šè¿‡ `chan<-` å’Œ `<-chan` é™åˆ¶å…¶æ–¹å‘, åˆ†åˆ«è¡¨ç¤ºåªèƒ½å‘é€å’Œåªèƒ½æ¥æ”¶

```go
func Send(ch chan<- int) {
    ch <- 123
}
func Receive(ch <-chan int) {
    data := <-ch
    fmt.Println(data)
}
```

#### éå†ç®¡é“
é€šè¿‡ `range` å…³é”®å­—å¯ä»¥éå† `channel`, ä½†è¦è®°å¾—åœ¨å‘é€æ–¹é€‚æ—¶å…³é—­ `channel`, å¦åˆ™ä¼šå¯¼è‡´æ­»é”

```go
ch := make(chan int, 10)

go func() {
    for i := 0; i < 10; i++ {
        ch <- i
    }
    close(ch)
}()

for data := range ch {
    fmt.Println(data)
}
```

## select
`select` è¯­å¥ç”¨äºå¤„ç†å¤šä¸ª `channel` çš„å¹¶å‘æ“ä½œ, å¦‚æœæ²¡æœ‰ `case` å¯æ‰§è¡Œ, åˆ™ä¼šé˜»å¡ (é™¤éå­˜åœ¨ `default`)

æ¯ä¸ª `case` è¯­å¥å¿…é¡»æ˜¯ä¸€ä¸ª `channel` æ“ä½œ (å‘é€æˆ–æ¥æ”¶), å½“æ»¡è¶³å¤šä¸ª `case` æ—¶, ä¼šéšæœºé€‰æ‹©ä¸€ä¸ªæ‰§è¡Œ; å½“ `default` å­˜åœ¨æ—¶, å¦‚æœæ²¡æœ‰å…¶ä»– `case` å¯æ‰§è¡Œ, åˆ™ä¼šæ‰§è¡Œ `default` (è€Œä¸ä¼šå†é˜»å¡)

```go
func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    ch3 := make(chan int)
    defer close(ch1)
    defer close(ch2)
    defer close(ch3)
    Send(ch1, 100)
    Send(ch2, 200)
    Send(ch3, 300)

    lock := make(chan struct{}, 1) // ç”¨æ¥æ§åˆ¶ä¸»çº¿ç¨‹ç»“æŸæ—¶æœº

    go func() {
    Loop:
        for {
            select {
            case data, ok := <-ch1: // ok ä¸ºæ˜¯å¦å¤„äºæ‰“å¼€çŠ¶æ€
                fmt.Println(data, ok)
            case data := <-ch2:
                fmt.Println(data)
            case data := <-ch3:
                fmt.Println(data)                
            case <-time.After(30 * time.Second):
                fmt.Println("timeout")
                break Loop
            }
        }
        lock <- struct{}{} // é‡Šæ”¾ä¸»çº¿ç¨‹
    }()

    <-lock // é˜»å¡ä¸»çº¿ç¨‹
}

// æ¯éš” xxx æ¯«ç§’å‘é€ä¸€ä¸ªæ•°æ®
func Send(ch chan<- int, sleepMS int) {
    for {
        ch <- 1
        time.Sleep(time.Duration(sleepMS) * time.Millisecond)        
    }    
}
```

## sync.WaitGroup
`sync.WaitGroup` å®è´¨æ˜¯ä¸€ä¸ªè®¡æ•°å™¨, ç”¨äºç­‰å¾…ä¸€ç»„ `goroutine` å®Œæˆ, é€šè¿‡ `Add` æ–¹æ³•å¢åŠ è®¡æ•°, `Done` æ–¹æ³•å‡å°‘è®¡æ•°, `Wait` æ–¹æ³•ç­‰å¾…è®¡æ•°ä¸º `0`

```go
import (
    "fmt"
    "sync"
)

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            fmt.Println(i)
        }(i)
    }
    wg.Wait()
}
```

## context
{% notel green æœ¬æ®µå†…å®¹ %}
{% btn `context.Background`::#context.Background %} {% btn `context.TODO`::#context.TODO %} {% btn `context.WithValue`::#context.WithValue %} {% btn `context.WithCancel`::#context.WithCancel %} {% btn `context.WithDeadline`::#context.WithDeadline %} {% btn `context.WithTimeout`::#context.WithTimeout %}
{% endnotel %}

`Context` æ˜¯ `Go` æä¾›çš„ä¸€ç§å¹¶å‘æ§åˆ¶çš„è§£å†³æ–¹æ¡ˆï¼Œç›¸æ¯”äºç®¡é“å’Œ `WaitGroup`ï¼Œå®ƒå¯ä»¥æ›´å¥½çš„æ§åˆ¶å­å­™åç¨‹ä»¥åŠå±‚çº§æ›´æ·±çš„åç¨‹

`Context` æœ¬èº«æ˜¯ä¸€ä¸ªæ¥å£ï¼Œåªè¦å®ç°äº†è¯¥æ¥å£éƒ½å¯ä»¥ç§°ä¹‹ä¸º `context`, ä¾‹å¦‚è‘—å `Web` æ¡†æ¶ `Gin` ä¸­çš„ `gin.Context`

`context` æ ‡å‡†åº“ä¹Ÿæä¾›äº†å‡ ä¸ªå®ç°ï¼Œå¦‚ `emptyCtx`ã€`cancelCtx`ã€`timerCtx`ã€`valueCtx` ç­‰. è¿™äº›å®ç°éƒ½æ˜¯ä¸å¯¹å¤–æš´éœ²çš„, åªèƒ½é€šè¿‡ `context` åŒ…æä¾›çš„æ–¹æ³•æ¥åˆ›å»º

```go
type Context interface {
    // deadline æ˜¯æˆªæ­¢æ—¶é—´ï¼Œå³ä¸Šä¸‹æ–‡åº”è¯¥å–æ¶ˆçš„æ—¶é—´
    // ç¬¬äºŒä¸ªå€¼æ˜¯æ˜¯å¦è®¾ç½® deadlineï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®åˆ™ä¸€ç›´ä¸º false
    Deadline() (deadline time.Time, ok bool)
    // å…¶è¿”å›å€¼æ˜¯ä¸€ä¸ªç©ºç»“æ„ä½“ç±»å‹çš„åªè¯»ç®¡é“
    // è¯¥ç®¡é“ä»…ä»…èµ·åˆ°é€šçŸ¥ä½œç”¨ï¼Œä¸ä¼ é€’ä»»ä½•æ•°æ®
    // å½“ä¸Šä¸‹æ–‡æ‰€åšçš„å·¥ä½œåº”è¯¥å–æ¶ˆæ—¶ï¼Œè¯¥é€šé“å°±ä¼šè¢«å…³é—­
    // å¯¹äºä¸€äº›ä¸æ”¯æŒå–æ¶ˆçš„ä¸Šä¸‹æ–‡ï¼Œå¯èƒ½ä¼šè¿”å› nil
    Done() <-chan struct{}
    // è¡¨ç¤ºä¸Šä¸‹å…³é—­çš„åŸå› ã€‚å½“ Done ç®¡é“æ²¡æœ‰å…³é—­æ—¶ï¼Œè¿”å› nil
    // å¦‚æœå…³é—­è¿‡åï¼Œä¼šè¿”å›ä¸€ä¸ª err æ¥è§£é‡Šä¸ºä»€ä¹ˆå…³é—­
    Err() error
    // è¯¥æ–¹æ³•è¿”å›å¯¹åº”çš„é”®å€¼
    // å¦‚æœ key ä¸å­˜åœ¨ï¼Œæˆ–è€…ä¸æ”¯æŒè¯¥æ–¹æ³•ï¼Œå°±ä¼šè¿”å› nil
    Value(key interface{}) interface{}
}
```

#### context.Background
`context.Background` æ˜¯ä¸€ä¸ª `emptyCtx` ç±»å‹çš„ `context`ï¼Œå®ƒæ˜¯ä¸€ä¸ªç©ºçš„ `context`ï¼Œæ²¡æœ‰ä»»ä½•å€¼ï¼Œä¹Ÿæ²¡æœ‰ä»»ä½•æˆªæ­¢æ—¶é—´ï¼Œä¹Ÿä¸æ”¯æŒå–æ¶ˆ, ä¸€èˆ¬ç”¨äºæ ¹ `context`

```go
import (
    "context"
    "fmt"
)

func main() {
    ctx := context.Background()
    fmt.Println(ctx.Deadline()) // 0001-01-01 00:00:00 +0000 UTC false
    fmt.Println(ctx.Err()) // nil
    fmt.Println(ctx.Value("key")) // nil
}
```

#### context.TODO
`context.TODO` æ˜¯ä¸€ä¸ª `emptyCtx` ç±»å‹çš„ `context`ï¼Œå®ƒå’Œ `context.Background` ç±»ä¼¼ï¼Œä½†æ˜¯å®ƒæ˜¯ä¸€ä¸ªå ä½ç¬¦ï¼Œè¡¨ç¤ºæœªæ¥ä¼šä¼ å…¥ä¸€ä¸ªçœŸæ­£çš„ `context`

```go
import (
    "context"
    "fmt"
)

func main() {
    ctx := context.TODO
    fmt.Println(ctx.Deadline()) // 0001-01-01 00:00:00 +0000 UTC false
    fmt.Println(ctx.Err()) // nil
    fmt.Println(ctx.Value("key")) // nil
}
```

#### context.WithValue
`context.WithValue` ç”¨äºåˆ›å»ºä¸€ä¸ªå¸¦æœ‰é”®å€¼å¯¹çš„ `context`ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ª `valueCtx` ç±»å‹çš„ `context`ï¼Œè¯¥ `context` ä¼šåœ¨åŸæœ‰çš„ `context` åŸºç¡¿ä¸Šæ·»åŠ ä¸€ä¸ªé”®å€¼å¯¹

```go
import (
    "context"
    "fmt"
)

func main() {
    ctx := context.WithValue(context.Background(), "key", "value")
    fmt.Println(ctx.Value("key")) // value
}
```

#### context.WithCancel
`context.WithCancel` ç”¨äºåˆ›å»ºä¸€ä¸ªå¯å–æ¶ˆçš„ `context`ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ª `cancelCtx` ç±»å‹çš„ `context`ï¼Œè¯¥ `context` ä¼šåœ¨åŸæœ‰çš„ `context` åŸºç¡€ä¸Šæ·»åŠ ä¸€ä¸ª `cancel` æ–¹æ³•

```go
import (
    "context"
    "fmt"
)

func main() {
    ctx, cancel := context.WithCancel(context.Background())
    go func() {
        <-time.After(3 * time.Second)
        cancel()
    }()
    <-ctx.Done()
    fmt.Println("done")
}
```

#### context.WithDeadline
`context.WithDeadline` ç”¨äºåˆ›å»ºä¸€ä¸ªå¸¦æœ‰æˆªæ­¢æ—¶é—´çš„ `context`ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ª `timerCtx` ç±»å‹çš„ `context`ï¼Œè¯¥ `context` ä¼šåœ¨åŸæœ‰çš„ `context` åŸºç¡€ä¸Šæ·»åŠ ä¸€ä¸ªæˆªæ­¢æ—¶é—´

```go
import (
    "context"
    "fmt"
)

func main() {
    ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(3 * time.Second))
    <-ctx.Done()
    fmt.Println("done")
}
```

#### context.WithTimeout
`context.WithTimeout` ç”¨äºåˆ›å»ºä¸€ä¸ªå¸¦æœ‰è¶…æ—¶æ—¶é—´çš„ `context`ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ª `timerCtx` ç±»å‹çš„ `context`ï¼Œè¯¥ `context` ä¼šåœ¨åŸæœ‰çš„ `context` åŸºç¡€ä¸Šæ·»åŠ ä¸€ä¸ªè¶…æ—¶æ—¶é—´

```go
import (
    "context"
    "fmt"
)

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 3 * time.Second)
    <-ctx.Done()
    fmt.Println("done")
}
```

## sync.Mutex
`sync.Mutex` æ˜¯ä¸€ç§äº’æ–¥é”, ç”¨äºä¿æŠ¤å…±äº«èµ„æº, é€šè¿‡ `Lock` å’Œ `Unlock` æ–¹æ³•æ¥æ§åˆ¶è®¿é—®

å½“ä¸€ä¸ª `goroutine` è°ƒç”¨ `Lock` æ–¹æ³•æ—¶, å¦‚æœé”å·²ç»è¢«å…¶ä»– `goroutine` å ç”¨, åˆ™ä¼šé˜»å¡, ç›´åˆ°é”è¢«é‡Šæ”¾; å½“ä¸€ä¸ª `goroutine` è°ƒç”¨ `Unlock` æ–¹æ³•æ—¶, ä¼šé‡Šæ”¾é”, å…è®¸å…¶ä»– `goroutine` è®¿é—®

```go
import (
    "sync"
    "fmt"
)

var mu sync.Mutex
var count int

func main() {
    for i := 0; i < 10; i++ {
        go func(mu *sync.Mutex) {
            mu.Lock()
            defer mu.Unlock()
            count++
        }(&mu)
    }
    mu.Lock()
    fmt.Println(count)
    mu.Unlock()
}
```

> æ³¨æ„: é€’å½’é”ä¼šå¯¼è‡´æ­»é”

## sync.RWMutex
`sync.RWMutex` æ˜¯ä¸€ç§è¯»å†™é”, ç”¨äºä¿æŠ¤å…±äº«èµ„æº, é€šè¿‡ `RLock` å’Œ `RUnlock` æ–¹æ³•æ¥æ§åˆ¶è¯»è®¿é—®, é€šè¿‡ `Lock` å’Œ `Unlock` æ–¹æ³•æ¥æ§åˆ¶å†™è®¿é—®

| æ–¹æ³• | æè¿° |
| :---: | :---: |
| `RLock` | è¯»é”å®š |
| `RUnlock` | è¯»è§£é” |
| `Lock` | å†™é”å®š |
| `Unlock` | å†™è§£é” |
| `TryRLock` | å°è¯•è¯»é”å®š, éé˜»å¡, å¦‚æœé”å·²è¢«å ç”¨, åˆ™è¿”å› `false` |
| `TryLock` | å°è¯•å†™é”å®š, éé˜»å¡, å¦‚æœé”å·²è¢«å ç”¨, åˆ™è¿”å› `false` |

- ä¸‹é¢çš„ `è¯»å–` å’Œ `å†™å…¥` æ˜¯æŒ‡åŠ è¯»é”å’ŒåŠ å†™é”, è¯»å†™æ•°æ®çš„æ“ä½œé€šå¸¸åœ¨åŠ è§£é”ä¹‹é—´è¿›è¡Œ
- è¯»é”å®šæ—¶, å…è®¸å…¶ä»– `goroutine` è¯»å–, ä½†ä¸å…è®¸å†™å…¥ (å†™å…¥æ—¶ä¼šé˜»å¡)
- å†™é”å®šæ—¶, ä¸å…è®¸å…¶ä»– `goroutine` è¯»å–æˆ–å†™å…¥ (è¯»å†™æ—¶ä¼šé˜»å¡)

## sync.Cond
`sync.Cond` æ˜¯ä¸€ç§æ¡ä»¶å˜é‡, ç”¨äºåœ¨ `goroutine` ä¹‹é—´ä¼ é€’ä¿¡å·, é€šè¿‡ `Wait`ã€`Signal` å’Œ `Broadcast` æ–¹æ³•æ¥æ§åˆ¶

| æ–¹æ³• | æè¿° |
| :---: | :---: |
| `sync.NewCond(l sync.Locker) *sync.Cond` | åˆ›å»ºä¸€ä¸ªæ¡ä»¶å˜é‡ |
| `c.Wait()` | é˜»å¡å½“å‰ `goroutine`, ç›´åˆ°æ”¶åˆ° `Signal` æˆ– `Broadcast` ä¿¡å· |
| `c.Signal()` | å”¤é†’ä¸€ä¸ªç­‰å¾…çš„ `goroutine` |
| `c.Broadcast()` | å”¤é†’æ‰€æœ‰ç­‰å¾…çš„ `goroutine` |

```go
import (
    "sync"
    "fmt"
    "time"
)

var mu sync.RWMutex
var cond = sync.NewCond(&mu)
var count int

func main() {
    // åˆ›å»º 10 ä¸ª goroutine
    for i := 0; i < 10; i++ {
        go func(count *int, mu *sync.RWMutex) {
            for count < 5 {
                cond.Wait()
            }
            mu.RLock()
            fmt.Println(count)
            mu.RUnlock()
        }(&count, &mu)
    }
    for {
        mu.Lock()
        count++
        mu.Unlock()
        // count æ¯åŠ  5 å°±å”¤é†’ä¸€ä¸ª goroutine
        if count%5 == 0 {
            cond.Signal()
        // count åŠ åˆ° 19 æ—¶å”¤é†’æ‰€æœ‰ goroutine
        } else if count == 19 {
            cond.Broadcast()
        }
        time.Sleep(time.Second)
    }
}
```

## sync.Once
`sync.Once` æ˜¯ä¸€ç§åªæ‰§è¡Œä¸€æ¬¡çš„æ“ä½œ, é€šè¿‡ `Do` æ–¹æ³•æ¥æ§åˆ¶

```go
import (
    "sync"
    "fmt"
)

var once sync.Once

func main() {
    for i := 0; i < 10; i++ {
        go func() {
            once.Do(func() {
                fmt.Println("only once")
            })
        }()
    }
}
```

> å¯¹äºå…¶ä»–ä¹ä¸ª `goroutine`, `Do` æ–¹æ³•ä¼šç›´æ¥è¿”å›, ä¸ä¼šæ‰§è¡Œä¼ å…¥çš„å‡½æ•°

## sync.Pool
`sync.Pool` æ˜¯ä¸€ç§å¯¹è±¡æ± , ç”¨äºå­˜å‚¨ä¸´æ—¶å¯¹è±¡, å‡å°‘å†…å­˜åˆ†é…å’Œé‡Šæ”¾çš„é¢‘ç‡. é€šè¿‡ `Get` å’Œ `Put` æ–¹æ³•æ¥æ§åˆ¶

```go
import (
    "sync"
    "fmt"
)

var pool sync.Pool

func main() {
    // è®¾ç½®ä¸€ä¸ªä¸´æ—¶å¯¹è±¡
    pool.New = func() interface{} {
        return "Hello, World!"
    }
    for i := 0; i < 1000; i++ {
        go func() {
            // è·å–ä¸€ä¸ªä¸´æ—¶å¯¹è±¡
            // å¦‚æœæ± ä¸­æœ‰å¯¹è±¡, åˆ™è¿”å›æ± ä¸­çš„å¯¹è±¡, å¦åˆ™è°ƒç”¨ New æ–¹æ³•åˆ›å»ºä¸€ä¸ªæ–°å¯¹è±¡
            data := pool.Get().(string)
            fmt.Println(data)
            // é‡Šæ”¾ä¸€ä¸ªä¸´æ—¶å¯¹è±¡
            // å¦‚æœä¸é‡Šæ”¾, ç­‰åŒäºä¸ç”¨ Pool çš„æƒ…å†µ, å³æ¯æ¬¡éƒ½åˆ›å»ºæ–°å¯¹è±¡
            pool.Put(data)
        }()
    }
}
```

> ä¸Šé¢çš„ä¾‹å­ä¸­, æ•´ä¸ªè¿‡ç¨‹åªåˆ›å»º/é”€æ¯äº†å‡ ä¸ªå¯¹è±¡, è€Œä¸æ˜¯ä¸€åƒä¸ª

#### æ³¨æ„äº‹é¡¹
- **ä¸´æ—¶å¯¹è±¡**ï¼š`sync.Pool` åªé€‚åˆå­˜æ”¾ä¸´æ—¶å¯¹è±¡ï¼Œæ± ä¸­çš„å¯¹è±¡å¯èƒ½ä¼šåœ¨æ²¡æœ‰ä»»ä½•é€šçŸ¥çš„æƒ…å†µä¸‹è¢« `GC` ç§»é™¤ï¼Œæ‰€ä»¥å¹¶ä¸å»ºè®®å°†ç½‘ç»œé“¾æ¥ï¼Œæ•°æ®åº“è¿æ¥è¿™ç±»å­˜å…¥ `sync.Pool` ä¸­
- **ä¸å¯é¢„çŸ¥**ï¼š`sync.Pool` åœ¨ç”³è¯·å¯¹è±¡æ—¶ï¼Œæ— æ³•é¢„çŸ¥è¿™ä¸ªå¯¹è±¡æ˜¯æ–°åˆ›å»ºçš„è¿˜æ˜¯å¤ç”¨çš„ï¼Œä¹Ÿæ— æ³•çŸ¥æ™“æ± ä¸­æœ‰å‡ ä¸ªå¯¹è±¡
- **å¹¶å‘å®‰å…¨**ï¼šå®˜æ–¹ä¿è¯ `sync.Pool` ä¸€å®šæ˜¯å¹¶å‘å®‰å…¨ï¼Œä½†å¹¶ä¸ä¿è¯ç”¨äºåˆ›å»ºå¯¹è±¡çš„ `New` å‡½æ•°å°±ä¸€å®šæ˜¯å¹¶å‘å®‰å…¨çš„ï¼Œ`New` å‡½æ•°æ˜¯ç”±ä½¿ç”¨è€…ä¼ å…¥çš„ï¼Œæ‰€ä»¥ `New` å‡½æ•°çš„å¹¶å‘å®‰å…¨æ€§è¦ç”±ä½¿ç”¨è€…è‡ªå·±æ¥ç»´æŠ¤

## sync.Map
`sync.Map` æ˜¯ä¸€ç§å¹¶å‘å®‰å…¨çš„ `map`, é€šè¿‡ `Store`ã€`Load`ã€`LoadOrStore`ã€`Delete`ã€`LoadAndDelete`ã€`Range` æ–¹æ³•æ¥æ§åˆ¶

ç”±äºéœ€è¦ä¿è¯å¹¶å‘å®‰å…¨, `sync.Map` ç›¸æ¯”äº `map` ä¼šæœ‰ä¸€äº›æ€§èƒ½æŸè€—

| æ–¹æ³• | æè¿° |
| :---: | :---: |
| `Load(key any) (value any, ok bool)` | è·å–æŒ‡å®šé”®çš„å€¼ |
| `Store(key, value any)` | è®¾ç½®æŒ‡å®šé”®çš„å€¼ |
| `LoadOrStore(key, value any) (value any, loaded bool)` | è·å–æˆ–è®¾ç½®æŒ‡å®šé”®çš„å€¼ |
| `Delete(key any)` | åˆ é™¤æŒ‡å®šé”®çš„å€¼ |
| `LoadAndDelete(key any) (value any, loaded bool)` | è·å–å¹¶åˆ é™¤æŒ‡å®šé”®çš„å€¼ |
| `Range(f func(key, value any) bool)` | éå†æ‰€æœ‰é”®å€¼å¯¹, å¦‚æœ `f` è¿”å› `false`, åˆ™åœæ­¢éå† |

## sync/atomic
`sync/atomic` åŒ…æä¾›äº†ä¸€äº›åŸå­æ“ä½œ. åŸå­æ“ä½œæŒ‡çš„æ˜¯åœ¨å•ä¸ª `goroutine` ä¸­æ‰§è¡Œçš„æ“ä½œ, ä¸ä¼šè¢«å…¶ä»– `goroutine` æ‰“æ–­, ä¿è¯äº†æ“ä½œçš„å®Œæ•´æ€§

åŸå­ç±»å‹æŒ‡çš„æ˜¯ `atomic.Value` (å¯ä»¥å­˜å‚¨é™¤ `nil` å¤–çš„ä»»ä½•å€¼)ã€`atomic.Bool`ã€`atomic.Int32`ã€`atomic.Int64`ã€`atomic.Uint32`ã€`atomic.Uint64`ã€`atomic.Pointer` ç­‰, æ¯ä¸ªåŸå­ç±»å‹éƒ½æœ‰ `Load`ã€`Store`ã€`Swap` ç­‰æ–¹æ³•

```go
import (
    "sync/atomic"
    "fmt"
)

func main() {
    var count atomic.Int32
    // å­˜å‚¨ä¸€ä¸ªå€¼
    count.Store(123) // atomic.StoreInt32(&count, 123)
    // äº¤æ¢ä¸€ä¸ªå€¼
    old := count.Swap(456) // atomic.SwapInt32(&count, 456)
    // åŠ å‡ä¸€ä¸ªå€¼
    count.Add(1) // atomic.AddInt32(&count, 1)
    count.Sub(1) // atomic.AddInt32(&count, -1)
    // è·å–ä¸€ä¸ªå€¼
    data := count.Load() // atomic.LoadInt32(&count)
}
```

#### CompareAndSwap / CAS
`CompareAndSwap` æ˜¯ä¸€ç§åŸå­æ“ä½œ, ç”¨äºæ¯”è¾ƒå¹¶äº¤æ¢, å¦‚æœå½“å‰å€¼ç­‰äºæ—§å€¼, åˆ™å°†æ–°å€¼å­˜å…¥, å¹¶è¿”å› `true`, å¦åˆ™è¿”å› `false`

`CAS` æ˜¯ä¸€ç§**ä¹è§‚é”**

```go
import (
    "sync/atomic"
    "fmt"
)

func main() {
    var count atomic.Int32
    // æ¯”è¾ƒå¹¶äº¤æ¢
    ok := count.CompareAndSwap(123, 456) // atomic.CompareAndSwapInt32(&count, 123, 456)
    fmt.Println(ok)
}
```

# ğŸš§æµ‹è¯•
